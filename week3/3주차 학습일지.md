# C작점 3주차 학습 일지

## 1. 배열

배열(array)은 동일한 종류의 데이터를 일련의 구조화된 집단으로 메모리에 구성한 것이다. 즉, 동일한 자료형을 동시에 여러 개 선언할 때 배열을 사용한다. int a[10]; 과 같이 선언된 배열 a가 있다고 하자. 이 문장은 int형의 변수 10개를 동시에 선언한 것으로, 배열명은 a이고 원소는 10개라는 의미이다. int형은 일반적으로 4바이트의 크기를 가지므로, a[0]부터 a[9]까지 10개의 정수를 수용할 수 있는 메모리 40바이트가 연속적으로 할당된다.


* 문자와 아스키코드

```C
#include <stdio.h>

int main(void)
{
	int a = 65;
	char b = 65;
  
	printf("%c %c", a, b);
	
	return 0;
}
```

C언어는 문자를 아스키코드의 숫자로써 인식하기 때문에, printf()로 출력 형식을 문자형(%c)로 지정하여 숫자를 출력할 경우, 그 숫자에 해당하는 문자가 출력된다. 아스키코드 65번에 해당하는 문자는 알파벳 대문자 'A'이므로 위의 코드의 실행 결과 A가 두번 출력된다.

```C
#include <stdio.h>

int main(void)
{
	int a = 'A';
	char b = 'A';
  
	printf("%d %d", a, b);
	
	return 0;
}
```


반대로, 정수형 변수를 문자로 초기화해도 정수형 변수에는 그 문자의 아스키코드가 저장된다. 따라서 printf()로 출력 형식을 정수형(%d)으로 지저아여 문자를 출력하여도, 그 문자에 해당하는 숫자가 출력된다. 알파벳 대문자 'A'의 아스키 코드는 65이므로 위의 코드 실행 결과 65가 두번 출력된다.

* 문자열

```c
char str1[] = {'a', 'b', 'c', 'd', 'e', '\0'};

char str2[] = "abcde";
```

배열과 2주차 때 학습한 조건문, 반복문을 활용해보기 위한 연습 문제로, 숫자와 알파벳이 섞인 문자열에서 소문자만 출력하는 프로그램을 만들어보기로 했다. 문자열은 문자(char)형의 데이터를 원소로 가지는 배열로, 마지막의 원소는 항상 문자열이 끝남을 나타내는 null표시로 ‘\0’이 들어간다. while() 반복문을 통해 cnt번째의 원소가 ‘\0’이 되는 것을 탈출 조건으로 하여 문자열의 길이 만큼 원소인 문자들을 검사할 수 있다. 컴퓨터는 char형의 각 문자를 아스키코드의 숫자로서 인식하기 때문에, if() 조건문을 통해 cnt번째의 검사할 원소가 a의 아스키코드 값과 z의 아스키코드 값 사이에 포함이 되는지를 판별하여 참이면 그 원소를 출력시킴으로써 문제를 해결할 수 있었다.


```C
#include <stdio.h>

int main(void)
{
	char array[] = "1 a C b D O z";
	
	int i;
	
	for(i=0; i<13; i++)
	{
		if('a'<=array[i] && array[i]<='z')
			printf("%c", array[i]);
	}
	
	printf("\n");
	
	i=0;
	
	while(array[i] != '\0')
	{
		if('a'<=array[i] && array[i]<='z')
			printf("%c", array[i]);
		
		i++;
	}
		
	return 0;
}
```


## 2. 포인터

포인터(poitner)는 C언어의 가장 대표적인 특징 중 하나로, 일반 변수의 메모리 주소를 값으로 가지는 변수이다. 포인터를 사용하면 변수명을 통하지 않고도 사용하고자 하는 대상에 직접 접근할 수 있어 프로그램이 간결하고 효율적으로 제어된다. 포인터 변수는 (자료형) \* (변수명); 과 같이 선언된다. \*은 (변수명)이 포인터 변수임을 표시하고, (자료형)은 포인터 변수인 (변수명)에 저장될 주소에 저장될 데이터의 유형을 지정한다. 예를 들어 int \* ptr; 이라는 문장은 정수형(int)의 자료를 담을 주소를 저장할 포인터 변수 ptr을 선언하는 문장이다. 

```c
#include <stdio.h>

int main(void)
{
	int a = 10;
	int *p = &a;
  
	printf("a의 주소 : %p \n", p);
	printf("p의 주소 : %p \n", &p);
	printf("p가 가리키는 a에 저장된 값 : %d \n", *p);

	return 0;
}
```

포인터 자료형으로 사용되는 연산자에는 주소 연산자와 간접 연산자가 있다. 주소 연산자 &는 일반 변수명에 사용하며, 해당 변수의 메모리 주소를 추출하는 연산자이다. 1주차와 2주차에 걸쳐서 살펴본 scanf(“%d”, &num); 에서 &가 이 주소 연산자이다. 즉, scanf() 함수는 앞에서 선언해놓은 변수의 주소에 입력받은 값을 저장하는 것이다. 간접 연산자 \*는 포인터 변수명에 사용하며, 주소가 저장되어있는 메모리 위치를 가리킨다. 정리하자면 만약 int \* p = &a; 라고 선언되었을 때, p는 a의 주소값, &p는 포인터 변수 p의 주소값, \*p는 a에 저장되있는 값을 의미한다.

```c
#include <stdio.h>

int main(void)
{
	int i, a[10] = {1, 5, 3, 6, 4, 7, 2, 9, 8, 0};
	
	for(i=0; i<10; i++){
		printf("a[i] : %d\n", a[i]);
		printf("*(a+i) : %d \n\n", *(a+i));
	}
	
	return 0;
}
```

포인터와 배열은 매우 긴밀히 연관되어있다. 앞에서 예시로 든 int a[10]; 라는 선언을 다시 보자. 배열의 이름은 배열의 시작 주소를 저장하는 포인터 상수이다. 즉 \*a와 a[0]은 동일한 의미이고, \*(a+i) 는 a[i]와 동일하다. 배열명은 그 자체로서 포인터이지만, 그 값이 변할 수 없다는 점에서 포인터 변수와 다르다. 포인터 변수 p에 대해 p++은 원래 p가 가리키던 곳의 다음 주소, \*p++은 그 주소에 들어있는 값을 의미하는 반면, 배열명 a는 a++와 같이 증감 연산자를 사용할 수 없다.
