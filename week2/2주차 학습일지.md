# C작점 2주차 학습 일지

## 1. 버퍼의 개념과 scanf()

함수 scanf()는 지난번의 스터디에서 학습한 표준입출력함수 중 하나로, 값을 키보드로부터 입력받을 때 사용하는 함수이다. scanf(“%출력형식”, &변수); 의 형태로 활용한다. 예를 들면 scanf(“%d”, &num); 은 num이라는 변수의 주소(&)에 정수형(%d)을 받는다는 의미이다. 비슷하게, scanf(“%c”, &chr); 은 chr이라는 변수에 문자형을 받는다. 

```c
#include <stdio.h>

int main(void)
{
    int number;
    char character;
    
    scanf("%d", &number);
    scanf("%c", &character);
    
    printf("%d", number);
    printf("%c", character);
    
    return 0;
}
```

위의 코드는 의도한 대로 실행이 될까? scanf()함수를 사용하여 문자형 자료를 받을 때는 주의를 기울여야한다. 문제는 실제로 키보드를 통해 값을 입력하고 나서 엔터키를 칠 때, 이 엔터를 \n으로 받아들이는 것에서 발생한다. 이전의 입력함수에서 값과 엔터를 입력하면 버퍼에 입력된 값과 \n이 들어가고, scanf()는 해당하는 자료형의 값만을 받아들이고 문자인 \n은 버퍼에 계속 남아있게 된다. 이 상태에서 scanf()로 문자형을 받아오게 한다면 \n이 입력되고 의도한 입력값이 변수에 저장되지 않게 된다.


```c
#include <stdio.h>

int main(void)
{
    int number;
    char character;
    
    scanf("%d", &number);
    getchar();
    scanf("%c", &character);
    
    printf("%d", number);
    printf("%c", character);
    
    return 0;
}
```

이 현상을 해결하기 위해서는 scanf()와 scanf(“%c”, &chr); 사이에서 버퍼를 비워주어야 한다. 우리가 이때까지 배운 내용을 이용하여 버퍼를 비우는 방법을 구현할 수 있을까 의논해본 결과 getchar()함수로 해결할 수 있었다. getchar()함수는 변수=getchar(); 의 형태로 활용해 입력값을 변수에 저장한다. 이것을 입력값을 받기만 하고 아무 변수에도 저장하지 않는 형태로 만들면 \n을 비우는 효과를 낼 수 있기 때문에 scanf(“%c”, &chr); 이전에 getchar();을 작성하는 것으로 버퍼 문제를 해결할 수 있었다.


## 2. 연산자 기초

연산자(operator)는 +, -, \*, / 와 같이 이미 정의된 연산을 수행하는 기호로, 어떤 변수가 데이터를 처리할 연산식을 만드는데 사용한다. 예를 들면 z = x + y;는 변수 z에 피연산자인 변수 x, y의 합(+)을 대입(=)한다는 의미의 문장이다. 이러한 연산자 중 공통적으로 수업에서 이해가 잘 안되었던 부분이 증감연산자이다. 증감연산자는 피연산자를 한 개만 사용하는, 즉 단항연산자인 산술연산자로, ++와 --가 있다. 각각 변수를 1만큼 증가시키고 감소시킨다는 의미이다. 
하지만 어떤 변수 a에 대해서 a++와 ++a 는 동작의 양상이 다르기 때문에 주의해야한다. 변수 a가 정수 0으로 초기화 되어있을 때, ++a; 는 a의 값이 바로 1로 증가시키지만, a++;는 이후에도 0의 값을 유지하다가 a가 어떤 수식에 먼저 적용된 후에야 변숫값을 1로 증가시킨다. 이러한 성질을 가진 a++은 반복문에서 반복횟수를 제어할 때 많이 활용된다. a=a+1; 과 동일한 일을 수행하지만, 처리속도가 a++가 조금 더 빠르기 때문에 사용한다.



